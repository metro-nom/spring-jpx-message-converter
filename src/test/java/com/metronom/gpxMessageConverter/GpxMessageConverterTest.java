/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.metronom.gpxMessageConverter;

import io.jenetics.jpx.GPX;
import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.Test;
import org.springframework.http.HttpInputMessage;
import org.springframework.http.HttpOutputMessage;
import org.springframework.http.MediaType;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.Map;

import static org.mockito.Mockito.*;

public class GpxMessageConverterTest {

    private GpxMessageConverter converter;

    @Before
    public void setUp() {
        converter = new GpxMessageConverter();
    }

    @Test
    public void shouldWriteGpx() throws Exception {
        GPX input = buildSampleGpx();

        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        HttpOutputMessage outputMessage = mock(HttpOutputMessage.class);
        when(outputMessage.getBody()).thenReturn(outputStream);

        converter.write(input, GpxMediaType.APPLICATION_GPX_XML.mediaType(), outputMessage);

        verify(outputMessage).getBody();
        String gpxString = outputStream.toString();
        GPX parsedOutputGpx = GPX.reader().fromString(gpxString);
        assertEquals(input, parsedOutputGpx);
    }

    @Test
    public void shouldReadGpx() throws Exception {
        GPX expected = buildSampleGpx();
        String gpxString = GPX.writer().toString(expected);

        ByteArrayInputStream inputStream = new ByteArrayInputStream(gpxString.getBytes());
        HttpInputMessage inputMessage = mock(HttpInputMessage.class);

        when(inputMessage.getBody()).thenReturn(inputStream);

        GPX actual = converter.read(GPX.class, inputMessage);

        assertEquals(expected, actual);
    }

    @Test
    public void shouldBeAbleToReadGpxClassIfTheMediaTypeIsCorrect() {
        assertTrue(converter.canRead(GPX.class, null));
        assertTrue(converter.canRead(GPX.class, MediaType.APPLICATION_XML));
        assertTrue(converter.canRead(GPX.class, MediaType.valueOf("application/gpx+xml")));

        assertFalse(converter.canRead(GPX.class, MediaType.valueOf("application/json")));

        assertFalse(converter.canRead(Map.class, null));
        assertFalse(converter.canRead(Map.class, MediaType.APPLICATION_XML));
        assertFalse(converter.canRead(Map.class, MediaType.valueOf("application/gpx+xml")));
    }

    @Test
    public void shouldBeAbleToWriteGpxClassIfTheMediaTypeIsCorrect() {
        assertTrue(converter.canWrite(GPX.class, null));
        assertTrue(converter.canWrite(GPX.class, MediaType.APPLICATION_XML));
        assertTrue(converter.canWrite(GPX.class, MediaType.valueOf("application/gpx+xml")));

        assertFalse(converter.canWrite(GPX.class, MediaType.valueOf("application/json")));

        assertFalse(converter.canWrite(Map.class, null));
        assertFalse(converter.canWrite(Map.class, MediaType.APPLICATION_XML));
        assertFalse(converter.canWrite(Map.class, MediaType.valueOf("application/gpx+xml")));
    }

    private GPX buildSampleGpx() {
        long firstTimestamp = LocalDateTime.of(2019, 8, 15, 10, 50, 0).toEpochSecond(ZoneOffset.UTC) * 1000;
        long secondTimestamp = firstTimestamp + 1000;

        return GPX.builder()
                .addTrack(track -> track.addSegment(
                        segment -> segment
                                .addPoint(point -> point.lat(49.0).lon(8.0).time(firstTimestamp))
                                .addPoint(point -> point.lat(49.5).lon(8.5).time(secondTimestamp))
                )).build();
    }
}
